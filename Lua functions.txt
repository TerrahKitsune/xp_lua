Misc global functions:

	-Returns a UUID from windows CoCreateGuid
	-returns nil if the UUID cannot be garantueed unique
	string UUID()

	-Sleep for 1 milisecond second or opt int, max 1000 (1 second)
	nil Sleep(opt int);
	
	--non nwnx functions
	nil CLS()
	fore,background GetTextColor()
	nil SetTextColor(fore,background)
	int GetKey()
	bool HasKeyDown()
	nil Put(text)
	bool ShellExecute(file, parameter)

	--Sets a function as a ticker function
	--if the function parameter isnt a function the ticker is disabled
	nil SetTicker(function, opt ms)

	--return memory in bytes used by lua
	int GetMemory()

	--called when GFF.exe shuts down can also be called to shut gff.exe down prematurely
	Exit()

	--key:
	--0: HKEY_LOCAL_MACHINE
	--1: HKEY_CLASSES_ROOT
 	--2: HKEY_CURRENT_CONFIG
	--3: HKEY_CURRENT_USER
	--4: HKEY_PERFORMANCE_DATA
	--5: HKEY_PERFORMANCE_NLSTEXT
	--6: HKEY_PERFORMANCE_TEXT
	--7: HKEY_USERS
	string GetRegistryValue(key,subkey,entry)

	ToggleConsole(bool)
	SetTitle(newtitle)

	ms Runtime()

Server:

	-Starts listening to port
	-returns nil and the wsa error on failure
	-returns a server instance on success (this will cancel if garbage collected)
	Server Server.Start(port)

	-Attempts connecting a client
	-returns nil and a wsa error on failure (wsa error is WOULDBLOCK) if there was no connection
	-returns a socket (intiger) on success
	socket Server:Accept()

	-Attempts receving data from a socket
	-Returns nil and a wsa error (1=disconnected, 0=not enough memory)
	-returns method (a string) and a table containing data from the source
	method,data Server:Recv(socket)

	-Attempts sending data to the peer, method should be a string max 16 characters
	-datatable should be a table containing string key with boolean, numeric or string values
	-returns false and a wsa error on failure (1=disconnected 0=not enough memory)
	boolean, wsaerror Server:Send(socket, method, datatable)

	-Returns an array containing all connected clients (integer sockets)
	-is empty if there are no clients
	array Server:Clients()

	-Returns the ip and port from the socket
	-returns nil on failure
	ip,port Server:GetIP(socket)

Client:

	-Attempts connecting to the address at port
	-on success this returns a client object
	-on failure it returns nil and a wsa error code
	Client Client.Connect(address, port)

	-Attempts receving data
	-Returns nil and a wsa error (1=disconnected, 0=not enough memory)
	-returns method (a string) and a table containing data from the source
	method,data Client:Recv()

	-Attempts sending data, method should be a string max 16 characters
	-datatable should be a table containing string key with boolean, numeric or string values
	-returns false and a wsa error on failure (1=disconnected 0=not enough memory)
	boolean, wsaerror Client:Send(method, datatable)

Process:

	-returns a table with process ids as keys and values as names
	table Process.All()

	-Opens a process, if no process ID is provided it opens the running instance
	Process Process.Open(opt id)

	-app = path to the application
	-cmd = commandline to be passed to the application
	-directory = path to the directory to run in
	-noconsole if true the process will not spawn its own console
	Process Process.Start(app,cmd,directory,noconsole)

	-Attempts to stop the process
	bool Process:Stop()

	-The return code from the process, if the process is still running this returns nil
	int/nil Process:GetExitCode()

	-Get the process ID
	int Process:GetID();

	-Get the process name
	string Process:GetName();

	-Get process utilization in percent since process start or since the last call to GetCPU
	number Process:GetCPU();

	-Get the current physical memory (ram) utilized by the process
	number Process:GetRAM();

	-Gets or sets a prio on the process
	-if no parameter is given this will return the current prio
	-if a prio is given then it'll attempt setting the prio returning true/false
	-https://msdn.microsoft.com/en-us/library/ms686219(v=vs.85).aspx
	int/bool Process:Priority(opt prio)

HTTP:

	-does a http (or https) request, method should be a http method IE "GET"
	-url = "http(s)://address:port/page"
	-content = content to tbe passed in the request
	-headers = key-value table containing the headers, content-length and host is automatically filled
	code, ok, contents, header HTTP.Request(method, url, content, headers)

	-Set a filepath, if a file is set then content in HTTP.Request will be nil
	-and the set file will contain the contents instead
	nil HTTP.SetFile(file)

	-Sets a message function
	-function(ms,total,processed,reciving)
	-ms = miliseconds since the request started
	-total = the total amount of bytes to receive (if content length)
	-processed = amount of bytes downloaded (or sent)
	-reciving = true if we're receving data, false if we're sending
	nil HTTP.SetMessageFunction(func)

MD5:
	
	-Returns a newly initilized instance of MD5
	MD5 MD5.New()

	-Digests data into the MD5 instance	
	nil MD5:Update(data)

	-Finilizes the digest and returns the hash as a hex string and a 16 byte string representation
	-if the digest is finalized already it just returns the previous result without doing anything
	hexstring, 16bytes MD:Finish()

MySQL:
	-Escapes a string using a mysql object
	string MySQL:EscapeString(string)

	-turns a string into a hex literal which can be used in queries
	-Does *not* need a mysql object
	string MySQL.EncodeString(string)

	-use the mysql library to connect to a server
	-if successful this returns a MySQL object that other functions are called from
	-returns nil on failure
	MySQL MySQL.Connect(address, user, password, database, opt port 3306)

	-runs querystring on the opened mysql object
	-returns true, rowsaffected on success or false and an error message on failure
	bool, msg MySQL:Query(querystring)

	-Advances the resultset to the next row
	-returns false if there is no more rows or there was none to begin with
	bool MySQL:Fetch()

	-Returns a table containing the the column names and their values
	-if an optional index is provided it'll return a single value from that index
	-1 indexed
	table (or single value) MySQL:GetRow(opt index)

Timer:

	-Returns a new timer object
	Timer Timer.New()

	-Returns true if the timer is running
	bool Timer:IsRunning()	

	-Resets the time elapsed back to 0
	nil Timer:Reset()

	-Starts (or Restarts) a timer
	nil Timer:Start()

	-Stops the timer
	nil Stop()

	-Returns the amount of time the timer has run for
	number (miliseconds) Timer:Elapsed()

SQLite:

	-Opens a new SQLite instance and returns the instance object
	-if a filename is provided it will attempt opening that file or create a new one
	-if no filename is given the sqlite database will be opened in memory
	-mode: 0: single thread (default) 1: multithreaded. 2: serialized
	-returns nil on failure
	SQLite SQLite.Open(opt filename, opt mode)

	-Runs a query on the sqlite object, preparedstatements should contain values matching the query
	-IE: "INSERT INTO Test (@Data)" then preparedstatements should contain a value with the key "Data"
	-returns true,"OK" on success, false and an error message on failure
	bool, txt SQLite:Query(querystring, preparedstatements)

	-Advance the recordset to the next row, returns false if there are no more rows
	bool SQLite:Fetch()

	-Returns a table containing the the column names and their values
	-if an optional index is provided it'll return a single value from that index
	-1 indexed
	table (or single value) SQLite:GetRow(opt index)

	-Executes a query, if a callback is present function(table) ... end
	-the results are pushed as key-value columnname: value tables to the callback function one at the time as strings
	-returns false if something failed
	-if no callback is passed any resultset (if any) is ignored
	-For more accurate data or binary data Query
	bool, txt SQLite:Execute(querystring, opt callback)

	-closes the database connection, it should not be used afterwards
	nil SQLite:Close()

FileSystem:

	-Returns an array containing all files that exists in path
	Array FileSystem.GetFiles(path)

	-Returns an array containing all directories that exists in path
	Array FileSystem.GetDirectories(path)

	-Returns a table containing file info:
	-isFolder bool
	-Size integer
	-Creation unix time when the file was created
	-Access unix time when the file was accessed
	-Write unix time when the file was written to
	-returns nil on failure
	FileInfo FileSystem.GetFileInfo(file)

	-Copies file source to destination
	-if overwrite is true existing file will be overwritten
	-returns false on failure
	bool FileSystem.Copy(source, destination, bool overwrite)

	-Moves file source to destination
	-true on success
	bool FileSystem.Move(source, destination)

	-Deletes source, returns true on success
	bool FileSystem.Delete(source)

	-Creates a directory at path
	-returns true on success
	bool FileSystem.CreateDirectory(path)

	-Creates a directory at path
	-Folder has to be empty
	-returns true on success
	bool FileSystem.RemoveDirectory(path)

	-Renames source to destination
	bool FileSystem.Rename(source, destination)
	
	-Retruns the current active directory in full path (the directory the program lives in)
	string FileSystem.CurrentDirectory()

TWODA (2da):

	-opens and parses a 2da file, returns nil on failure
	TWODA TWODA.Open(file);

	-Returns the data from row depending on index (0 based) or columnname (case sensetive)
	-returns nil on failure
	string TWODA:Get2DAString(row, index or columnname)

	-Returns a table key-value of the row
	table TWODA:Get2DARow(row);

	-Returns an array of columnnames, number of rows and version of the 2da
	array, numbrows, version TWODA:GetInfo();

TLK:

	-Open a tlk file, returns nil if the file is not a valid tlk file
	TLK TLK.Open(filename)

	-Return all entries in a table key is the strref
	-index starts at 0 rather then 1
	-returns nil on failure
	table TLK:GetAll()

	-Read a single strref of the tlk, returns nil on failure
	string TLK:Get(strref)

	-return the number of entries, languageid and version of the tlk
	count,languageid,version TLK:GetInfo()
ERF:
	
	-opens filename as a erf returning a erf object
	-entries = the number of resources in the file
	-filetype = what kind of file it is "ERF ", "MOD " etc
	-version = what the version is "V1.0"
	ERF, entries, filetype, version ERF.Open(filename)

	-Returns an array containing localized strings describing the container
	-localsized string is a table containing:
	-LanguageID int
	-String string
	array of localized strings ERF:GetStrings()

	-Returns an array of tables each containing these fields:
	-ResRef string (max 16 characters)
	-ResID int (key to get the actual resource in GetResource)
	-ResType int (type of resource)
	-Unused int 0
	array of keys ERF:GetKeys()

	-Returns a binary string from the ResID provided
	-ResID is modified to be 1 index'ed instead of 0 indexed
	binary ERF:GetResource(ResID);
GFF:

	-Opens file and attempts decodings its content as a gff
	-Throws errors on failure
	struct GFF.OpenFile(file)

	-Deserializes a string into a gff
	-Throws errors on failure
	struct GFF.OpenString(string)

	-Save gff to file, overwrites the file if it exists
	-Throws errors on failure
	nil GFF.SaveToFile(gff, file)

	-returns a serilized version of the gff as a binary string
	-Throws errors on failure
	string GFF.SaveToString(gff)

	*gff parameters are top structs as described below

struct:

	*4 chars "BIC", "UTI" etc, only exists on toplevel struct
	string FileType

	*4 chars describing the version usually "V3.2" topstruct only
	string FileVersion

	*programmer defined int of the struct type topstruct is always 0xFFFFFFFF
	int Type

	*Number of fields loaded in Field
	*Largly irrelevant as its recalculated when the gff is saved
	int FieldCount

	*1 index array of all fields in the array
	array Fields

	*The gff type for this table, this can be "topstruct" or "struct"
	string gff

field:

	*Int that represents the type in the field
	*0 = byte
	*1 = char
	*2 = word
	*3 = short
	*4 = dword
	*5 = int
	*6 = dword64
	*7 = int64
	*8 = float
	*9 = double
	*10 = string (CExoString)
	*11 = ResRef (no space lowercase string max 16 characters)
	*12 = CExoLocString
	*13 = string (of binary data)
	*14 = struct
	*15 = array of structs (list)
	int Type

	*Name of this field (should not be longer then 16 chars)
	string Label

	*Contains the data as speificed by the Type (see GFFTYPES)
	variable Data

	*The gff type for this table, its always "field" on a field
	string gff

CExoLocString:

	*Index into the tlk files, this is 0xFFFFFFFF it unused
	int StringRef

	*The amount of strings this CExoLocString contains
	*Largly irrelevant as its recalculated when the gff is saved
	int StringCount

	*Total size in bytes (minus this field) that the CExoLocString contains
	*Largly irrelevant as its recalculated when the gff is saved
	int TotalSize

	*An array that contains the CExoLocSubstrings
	*this will be empty rather then nil if there are none
	array Strings

CExoLocStringSubString:

	*This is equal to LanguageID * 2 + gender (0 for masculine 1 for feminine)
	int StringID

	*Length of the string
	*Largly irrelevant as its recalculated when the gff is saved
	int StringLength

	*The string this exolocsubstring contains
	string String