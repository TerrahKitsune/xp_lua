Misc global functions:

	-Returns a UUID from windows CoCreateGuid
	-returns nil if the UUID cannot be garantueed unique
	string, raw16bytestring UUID()

	-Sleep for 1 milisecond second or opt int, max 1000 (1 second)
	nil Sleep(opt int);
	
	-Retrives the last error code as a message and code, if no lasterrorcode is provided it'll retrive it
	string, code GetLastError(opt lasterrorcode)

	--non nwnx functions
	nil CLS()
	fore,background GetTextColor()
	nil SetTextColor(fore,background)
	int GetKey() -waits for a keystroke or if its a pipe reads a single byte from stdin, returns -1 on failure
	bool HasKeyDown()
	nil Put(text)
	bool ShellExecute(file, parameter)

	--Sets a function as a ticker function
	--if the function parameter isnt a function the ticker is disabled
	nil SetTicker(function, opt ms)

	--return memory in bytes used by lua
	int GetMemory()

	--called when GFF.exe shuts down can also be called to shut gff.exe down prematurely
	Exit()

	--key:
	--0: HKEY_LOCAL_MACHINE
	--1: HKEY_CLASSES_ROOT
 	--2: HKEY_CURRENT_CONFIG
	--3: HKEY_CURRENT_USER
	--4: HKEY_PERFORMANCE_DATA
	--5: HKEY_PERFORMANCE_NLSTEXT
	--6: HKEY_PERFORMANCE_TEXT
	--7: HKEY_USERS
	string GetRegistryValue(key,subkey,entry)

	ToggleConsole(bool)
	SetTitle(newtitle)

	ms Runtime()

	-Contains special characters 0 - 31 (http://www.asciitable.com/)
	-Example c.LF = '\n'
	table c

	-A key(resourceid) value (extension) table used to determine the extensions used for erf containers
	-can be modifed during runtime
	table ResList

	-A string variable that is set by io.tmpfile() containing the filename of the created file
	LAST_TEMP_FILE

	-Array containing commandline parameters passed though to gff.exe
	ARGS[]

Stream:

	-Create a new stream object
	-initialsize is the size that should be allocated at the start (default 1 mb)
	Stream Stream.Create(opt initialsize);

	-Write a byte at the current position in the stream and advance the position
	-byte should be between 0-255
	-returns false if unable to write and an error message
	bool, err Stream:WriteByte(byte);

	-Read the byte at the current position and advance the position
	-byte 0-255 returns -1 on failure (such as end of stream)
	byte Stream:ReadByte();

	-Reads a byte but does not advance the position
	-byte 0-255 returns -1 on failure (such as end of stream)
	-If pos is omitted it reads the current position, 0 indexed
	byte Stream:PeekByte(opt pos);

	-Writes a number, string, bool or other stream (from position to end)
	-returns number of bytes written
	int Stream:Write(obj, opt size);

	-Writes a string to the end of the stream reguardless of position
	int Stream:Buffer(str);

	-Reads a number of bytes and returns it as a string
	-Reads from the current position, if length is omitted it reads to the end
	string Stream:Read(opt length);

	-Retrives the current position and the length of the stream
	position, length Stream:GetInfo();

	length Stream:len();
	pos Stream:pos();

	-Sets the current position in the stream
	-If no position is given the stream is rewinded to 0
	void Stream:Seek(opt pos)

	bool Stream:WriteFloat()
	number Stream:ReadFloat()

	bool Stream:WriteDouble()
	number Stream:ReadDouble()

	bool Stream:WriteShort()
	int Stream:ReadShort()

	bool Stream:WriteUnsignedShort()
	int Stream:ReadUnsignedShort()

	bool Stream:WriteInt()
	int Stream:ReadInt()

	bool Stream:WriteUnsignedInt()
	int Stream:ReadUnsignedInt()

	bool Stream:WriteLong()
	int Stream:ReadLong()

	bool Stream:WriteUnsignedLong()
	int Stream:ReadUnsignedLong()

Env:

	-Creates a new environment table with said name, discards any old
	table Env.Create(name);	

	-Retrives an environment table by name, nil if none exists
	table Env.Get(name);

	-Returns an existing table or creates a new one if it does not exist
	table Env.GetOrCreate(name);

	-Gets the table that contains all other environment tables
	table Env.Meta();

Zip:

	-Opens/creates a zipfile
	-returns nil, error on failure
	Zip Zip.Open(zipfile)

	-Adds a file as key into the zipfile, file should be the path to file
	-returns nil, error on failure
	-returns the index the data was placed in on success
	int Zip:AddFile(key, file)

	-Adds data (a string) as key into the zip file
	-returns nil, error on failure
	-returns the index the data was placed in on success
	int Zip:AddData(key, data)

	-Extract data from a zip file by key or index
	-if a target file is given the data will be extrated to that file
	-if no file is given then the data will be returned on success
	-returns nil, error on failure
	true/data Zip:Extract(key/index, opt targetfile)

	-Retrive info about a key/index from the zipfile
	-keys:
	-comp_method
	-comp_size
	-crc
	-encryption_method
	-flags
	-index
	-mtime
	-name
	-size
	-valid
	-returns nil on failure
	table Zip:GetInfo(key/index)

	-Mark a file as deleted within the zip
	int Zip:Delete(key/index)

	-Retrives all keys existing in the zipfile
	array Zip:GetFiles()

	-Close an open zipfile
	nil Zip:Close()
Server:

	-Creates a server instance on the port
	-Returns nil and errormsg on failure
	Server Server.Start(port)

	-Stops the server, terminating the socket and associated resources
	nil Server:Stop()

	-Returns a network event
	-Returns nil if there are no events
	-Returns table on success with fields:
	-socket: client socket
	-type: event type (see types)
	-data: binary/string containing the data
	event/nil Server:GetEvent()

	-Disconnect a client by socket
	bool Server:Disconnect(socket)

	-Send data (string) to a client by socket
	bool Server:Send(socket,data)

	-Set a function to run when a server instance is started
	-function(server) ...
	nil Server.SetStartFunc(function)

	-Retrive all clients
	-key = socket
	-value = address
	table Server:GetClients()
Client:

	-Start a client
	Client Client.Connect(address, port)

	-Retrive the status of the client
	-first bool is if the client is considered connected or not
	-second is the last errorcode if any
	bool/error Client:Status()
		
	-Disconenct the client, client object should not be used after this
	nil Client:Disconnect()
	
	-Returns a network event
	-Returns nil if there are no events
	-Returns table on success with fields:
	-socket: client socket
	-type: event type (NETEVENT_CONNECTED 1, NETEVENT_DISCONNECTED 2, NETEVENT_SEND 3, NETEVENT_RECEIVE 4)
	-data: binary/string containing the data
	event/nil Client:GetEvent()

	-Send data (string) to the server
	bool Client:Send(data)

Pipe:

	-Creates a named pipe and opens it
	-Name should be just the name, no path
	-default 1 instance, 1024 buffersize, timeout 1000 (miliseconds), write true, read true
	-returns nil and error code on failure
	Pipe Pipe.Create(name, opt maxinstances, opt buffersize, opt timeout, opt write, opt read);

	-Opens an existing pipe
	-Name should be just the name, no path
	- write true, read true
	-returns nil and error code on failure
	Pipe Pipe.Open(name, opt write, opt read)

	-Writes a string to a pipe
	-returns the number of written bytes
	-returns nil and error code on failure
	int Pipe:Write(string)

	-Reads from a pipe
	-returns nil if there was nothing to read
	string Pipe:Read(opt buffersize)

	-Reads a single byte from the pipe as an int
	-returns -1 if there was nothing read
	int Pipe:ReadByte();

	-Writes a single byte (number 0-255) to the stream
	-returns true/false on success or not
	bool Pipe:WriteByte(byte);

	-Closes a pipe, it should not be used after closing
	nil Pipe:Close();

Process:

	-returns a table with process ids as keys and values as names
	table Process.All()

	-Opens a process, if no process ID is provided it opens the running instance
	Process Process.Open(opt id)

	-app = path to the application
	-cmd = commandline to be passed to the application
	-directory = path to the directory to run in
	-noconsole if true the process will not spawn its own console
	-redirectinputoutput (default false) if true enables ReadFromPipe and WriteToPipe, this can also be a mask 0x1 stdin, 0x2 stdout, 0x4 stderr
	Process Process.Start(app,cmd,directory,noconsole, opt redirectinputoutput)

	-Reads from the the child process stdout
	-only works if redirectinputoutput was true when a process was started
	-returns nil on failure
	string Process:ReadFromPipe(opt buffersize)

	-Writes a string to the childs stdin
	-only works if redirectinputoutput was true when a process was started
	-returns number of bytes written
	int Process:WriteToPipe();

	-Same as ReadFromPipe but reads from stderr
	string Process:ReadErrorFromPipe(opt buffersize);

	-Attempts to stop the process
	bool Process:Stop()

	-The return code from the process, if the process is still running this returns nil
	int/nil Process:GetExitCode()

	-Get the process ID
	int Process:GetID();

	-Get the process name
	string Process:GetName();

	-Get process utilization in percent since process start or since the last call to GetCPU
	number Process:GetCPU();

	-Get the current physical memory (ram) utilized by the process
	number Process:GetRAM();

	-Gets or sets a prio on the process
	-if no parameter is given this will return the current prio
	-if a prio is given then it'll attempt setting the prio returning true/false
	-https://msdn.microsoft.com/en-us/library/ms686219(v=vs.85).aspx
	int/bool Process:Priority(opt prio)

	-Gets or sets the affinity mask for the process
	-Returns the process and system affinity masks
	-returns nil on failure
	int, int Process:Affinity(opt newmask);

	-Retrives an array of all threads in the process
	-Thread object:
	-ID: int id of the thread
	-BasePrio: Priority for the thread
	-DeltaPrio: 
	array Process:Threads();

HTTP:

	-does a http (or https) request, method should be a http method IE "GET"
	-url = "http(s)://address:port/page"
	-content = content to tbe passed in the request
	-headers = key-value table containing the headers, content-length and host is automatically filled
	-Returns http object
	Http Http.Start(method, url, content, headers)

	-Sets the timeout on the running request
	-0 or less = infinite
	nil Http:SetTimeout(timeout)

	-Retrives the results from the http request
	-if the http request is still in progress this call will block until its finished
	-returns nil, msg on error
	code, ok, contents, header Http:GetResult()

	-Returns the status on a http request
	-IsRunning bool: is the request still running?
	-ms: miliseconds the request has been running for
	-sent: bytes sent
	-recv: bytes recieved
	IsRunning, ms, sent, recv Http:GetStatus()

MD5:
	
	-Returns a newly initilized instance of MD5
	MD5 MD5.New()

	-Digests data into the MD5 instance	
	nil MD5:Update(data)

	-Finilizes the digest and returns the hash as a hex string and a 16 byte string representation
	-if the digest is finalized already it just returns the previous result without doing anything
	hexstring, 16bytes MD:Finish()

MySQL:
	-Escapes a string using a mysql object
	string MySQL:EscapeString(string)

	-turns a string into a hex literal which can be used in queries
	-Does *not* need a mysql object
	string MySQL.EncodeString(string)

	-Set the desired timeout on the connection (read,write and connect)
	nil MySQL:SetTimeout(timeout)

	-use the mysql library to connect to a server
	-if successful this returns a MySQL object that other functions are called from
	-Timeout in seconds, use SetTimeout if you want to change it
	-returns nil on failure
	MySQL MySQL.Connect(address, user, password, database, opt port 3306, opt timeout 3600)

	-Closes the connection, it should *NOT* be used afterwards
	MySQL:Close();

	-runs querystring on the opened mysql object
	-async is true then the mysql query will run async, async results are stored as opposed to used
	-use MySQL:IsRunning() and MySQL:GetResult() to evaluate the state of an async query
	-returns true, rowsaffected on success or false and an error message on failure
	bool, msg MySQL:Query(querystring, async=false)

	-Returns true if the connection is running an async query
	bool MySQL:IsRunning();

	-Evaluate the result of an async query
	-If the query is still running this will wait
	-returns the result MySQL:Query returns on non async queries for async queries
	bool, msg MySQL:GetResult();

	-Advances the resultset to the next row
	-Using on an async query will cause blocking until the query is finished
	-returns false if there is no more rows or there was none to begin with
	bool MySQL:Fetch()

	-Changes the default database to database (the one that gets reconnected to)
	-and runs "USE DATABASE `database`;"
	-returns the same as MySQL:Query
	bool, msg MySQL:ChangeDatabase(database)

	-Returns a table containing the the column names and their values
	-if an optional index is provided it'll return a single value from that index
	-1 indexed
	table (or single value) MySQL:GetRow(opt index)

	-Forks the result into a seperate object
	-useful for async querries where you wish to process the result while a new query is running
	MySQLResult MySQL:ForkResult()

	-Toggles if GetRow should always return all data as strings or as their proper typing
	-default: false
	nil MySQL:ToggleAsString(bool)

	MySQLResult:

	-Same as MySQL:GetRow()
	table (or single value) MySQLResult:GetRow(opt index)

	-Same as MySQL:Fetch()
	bool MySQLResult:Fetch();

	-Retrive the number of rows in a stored result, this is 0 on used results
	int MySQLResult:Count()

	-Toggles if GetRow should always return all data as strings or as their proper typing
	-default: inherited from the MySQL object that created the result
	nil MySQLResult:ToggleAsString(bool)

Timer:

	-Returns a new timer object
	Timer Timer.New()

	-Returns true if the timer is running
	bool Timer:IsRunning()	

	-Resets the time elapsed back to 0
	nil Timer:Reset()

	-Starts (or Restarts) a timer
	nil Timer:Start()

	-Stops the timer
	nil Stop()

	-Returns the amount of time the timer has run for
	number (miliseconds) Timer:Elapsed()

SQLite:

	-Opens a new SQLite instance and returns the instance object
	-if a filename is provided it will attempt opening that file or create a new one
	-if no filename is given the sqlite database will be opened in memory
	-mode: 0: single thread (default) 1: multithreaded. 2: serialized
	-returns nil on failure
	SQLite SQLite.Open(opt filename, opt mode)

	-Runs a query on the sqlite object, preparedstatements should contain values matching the query
	-IE: "INSERT INTO Test (@Data)" then preparedstatements should contain a value with the key "Data"
	-returns true,"OK" on success, false and an error message on failure
	bool, txt SQLite:Query(querystring, preparedstatements)

	-Advance the recordset to the next row, returns false if there are no more rows
	bool SQLite:Fetch()

	-Returns a table containing the the column names and their values
	-if an optional index is provided it'll return a single value from that index
	-1 indexed
	table (or single value) SQLite:GetRow(opt index)

	-Executes a query, if a callback is present function(table) ... end
	-the results are pushed as key-value columnname: value tables to the callback function one at the time as strings
	-returns false if something failed
	-if no callback is passed any resultset (if any) is ignored
	-For more accurate data or binary data Query
	bool, txt SQLite:Execute(querystring, opt callback)

	-closes the database connection, it should not be used afterwards
	nil SQLite:Close()

Image: 
	
	--ALL COORDINATES ARE 1 INDEXED

	-Take a screenshot with the desired width and height on a monitor
	-If no parameters are given it'll take a full screenshot of the first monitor
	Image Image.Screenshot(width, height, startx, starty, monitor)

	-Saves an image as a bitmap (bmp)
	bool Image:Save(filename)

	-Loads a bmp file
	-returns nil, message on failure
	Image Image.Load(filename);

	-Create an empty bmp with the desired width and height
	-Returns nil, message on failure
	Image Image.Create(Width, Height)

	-Create a cropped image from another image
	-returns nil, message on failure
	Image Image:Crop(Width, Height, StartX, StartY)

	-Returns raw bit map vector
	-e.g array[1].r = first red, array[1].g, array[1].b
	array Image:GetPixels()

	-Sets the raw pixles to that of the given array
	-returns false, message on failure
	bool Image:SetPixels(pixel)

	-Returns pixels in a matrix
	-matrix[1][1].r = first red, matrix[1][1].g, matrix[1][1].b
	matrix Image:GetPixelMatrix()

	-Sets the raw pixles to that of the given matrix
	-returns false, message on failure
	bool Image:SetPixelMatrix(pixelmatrix)

	-Get a single pixel
	-Returns a table containing r,g,b
	pixel Image:GetPixel(y, x);

	-Set a single pixel
	-pixel should be a table containing r,g,b
	void Image:SetPixel(y, x, pixel);

	-Retrive the dimentions of an image
	width, height Image:GetSize()

	-Discards the image from memory
	-the image item should *not* be used after this
	void Image:Close();

FileSystem:

	-Returns an array containing all files that exists in path
	Array FileSystem.GetFiles(path, opt filter)

	-Returns an array containing all directories that exists in path
	Array FileSystem.GetDirectories(path, opt filter)

	-Returns a table containing file info:
	-isFolder bool
	-Attributes attribute flags (int)
	-Size integer
	-Creation unix time when the file was created
	-Access unix time when the file was accessed
	-Write unix time when the file was written to
	-returns nil on failure
	FileInfo FileSystem.GetFileInfo(file)

	-Copies file source to destination
	-if overwrite is true existing file will be overwritten
	-returns false on failure
	bool FileSystem.Copy(source, destination, bool overwrite)

	-Moves file source to destination
	-true on success
	bool FileSystem.Move(source, destination)

	-Deletes source, returns true on success
	bool FileSystem.Delete(source)

	-Creates a directory at path
	-returns true on success
	bool FileSystem.CreateDirectory(path)

	-Creates a directory at path
	-Folder has to be empty
	-returns true on success
	bool FileSystem.RemoveDirectory(path)

	-Renames source to destination
	bool FileSystem.Rename(source, destination)
	
	-Retruns the current active directory in full path (the directory the program lives in)
	string FileSystem.CurrentDirectory()

	-Sets the current directory (where relative paths start)
	-returns true/false on success or failure
	bool FileSystem.SetCurrentDirectory(dir)

	-Returns path+filename of a temporary file
	-If pathonly is true it'll only return the path to the temp directory
	string FileSystem.GetTempFileName(optional bool pathonly)

	-Returns an array of drives
	-If a drive is specified it returns a table containing info for that drive
	-each drive is a table containing:
	-Drive: string letter (A,B,C,D)
	-Type: int (0 unknown, 1 not mounted, 2 removable, 3 fixed, 4 remote, 5 cdrom, 6 ramdisk)
	-FreeBytesAvailableToCaller: number of bytes available to the caller (this environment)
	-TotalNumberOfBytes: Total size in bytes of the drive
	-TotalNumberOfFreeBytes: total number of free bytes
	array FileSystem.GetDrives(opt drive)

TWODA (2da):

	-opens and parses a 2da file, returns nil on failure
	TWODA TWODA.Open(file);

	-Returns the data from row depending on index (0 based) or columnname (case sensetive)
	-returns nil on failure
	string TWODA:Get2DAString(row, index or columnname)

	-Returns a table key-value of the row
	table TWODA:Get2DARow(row);

	-Returns an array of columnnames, number of rows and version of the 2da
	array, numbrows, version TWODA:GetInfo();

TLK:

	-Creates a TLK file from a table and opens it
	-languageid: default 0(english)
	-version: must be 4 characters default V3.0
	-array *MUST* start on 0 and be without gaps, empty strings are used as not present (same as the result from TLK:GetAll)
	TLK TLK.Create(filename, array, opt languageid, opt version)

	-Open a tlk file, returns nil if the file is not a valid tlk file
	TLK TLK.Open(filename)

	-Return all entries in a table key is the strref
	-index starts at 0 rather then 1
	-returns nil on failure
	table TLK:GetAll()

	-Read a single strref of the tlk, returns nil on failure
	-Returns a table containg the stringref data:
	-Flags: 0x0001 (Texts exists), 0x0002 (Sound exists), 0x0004 (Sound length exists)
	-SoundResRef: if sound exists this is the resref to it
	-VolumeVariance: not used
	-PitchVariance: not used
	-String: actual string data, is empty string if it doesnt exist
	-SoundLength: Length of the sound
	table TLK:Get(strref)

	-Updates the tlk file with new sound info for a strref
	-if no soundresref is empty sound info will be stripped. soundresref cannot be longer then 16 characters.
	-soundlength (float) if provided will flag as having a sound length and set it, if not it'll unflag and set to 0
	-VolumeVariance: not used DWORD
	-PitchVariance: not used DWORD
	bool TLK:SetSoundInfo(strref, soundresref, opt soundlength, opt VolumeVariance, opt PitchVariance);

	-sets a stringref in the tlk, if the stringref wasnt present it'll be flagged as such and written at the end
	-if the string is larger then the original then it will be written at the end of the file instead
	-if newstring is an empty string the entry will instead be flagged as not present (deleted)
	bool TLK:Set(strref, newstring)

	-Defragments the tlk files ensuring all strings are written packed end to end with no gaps
	-extra adds empty extra entries at the end of the file
	bool TLK:Defragment(opt extra)

	-return the number of entries, languageid and version of the tlk
	count,languageid,version TLK:GetInfo()
ERF:
	
	-opens filename as a erf returning a erf object
	-entries = the number of resources in the file
	-filetype = what kind of file it is "ERF ", "MOD " etc
	-version = what the version is "V1.0"
	ERF, entries, filetype, version ERF.Open(filename)

	-Create an erf file
	-filenae = the path+name of the file to create
	-type header, a 4 character field in the header that describes the file IE "HAK\0"
	-filelist an array containing the files+path to include in the erf
	-version default 1. 1 = nwn1 2 = nwn2 erfs
	-desc default "LUA" what the description should be
	ERF ERF.Create(filename, typeheader, filelist, opt version, opt desc);

	-Returns an array containing localized strings describing the container
	-localsized string is a table containing:
	-LanguageID int
	-String string
	array of localized strings ERF:GetStrings()

	-Returns an array of tables each containing these fields:
	-ResRef string (max 16 characters)
	-ResID int (key to get the actual resource in GetResource)
	-ResType int (type of resource)
	-File name of the file with extension
	-Unused int 0
	array of keys ERF:GetKeys()

	-Returns a binary string from the ResID provided
	-ResID is modified to be 1 index'ed instead of 0 indexed
	binary ERF:GetResource(ResID);

	-Extracts a file to the desired path/folder
	-will overwrite existing files
	nil ERF:Extract(ResID, targetfile);
GFF:

	-Opens file and attempts decodings its content as a gff
	-Throws errors on failure
	struct GFF.OpenFile(file)

	-Deserializes a string into a gff
	-Throws errors on failure
	struct GFF.OpenString(string)

	-Save gff to file, overwrites the file if it exists
	-Throws errors on failure
	nil GFF.SaveToFile(gff, file)

	-returns a serilized version of the gff as a binary string
	-Throws errors on failure
	string GFF.SaveToString(gff)

	*gff parameters are top structs as described below

struct:

	*4 chars "BIC", "UTI" etc, only exists on toplevel struct
	string FileType

	*4 chars describing the version usually "V3.2" topstruct only
	string FileVersion

	*programmer defined int of the struct type topstruct is always 0xFFFFFFFF
	int Type

	*Number of fields loaded in Field
	*Largly irrelevant as its recalculated when the gff is saved
	int FieldCount

	*1 index array of all fields in the array
	array Fields

	*The gff type for this table, this can be "topstruct" or "struct"
	string gff

field:

	*Int that represents the type in the field
	*0 = byte
	*1 = char
	*2 = word
	*3 = short
	*4 = dword
	*5 = int
	*6 = dword64
	*7 = int64
	*8 = float
	*9 = double
	*10 = string (CExoString)
	*11 = ResRef (no space lowercase string max 16 characters)
	*12 = CExoLocString
	*13 = string (of binary data)
	*14 = struct
	*15 = array of structs (list)
	int Type

	*Name of this field (should not be longer then 16 chars)
	string Label

	*Contains the data as speificed by the Type (see GFFTYPES)
	variable Data

	*The gff type for this table, its always "field" on a field
	string gff

CExoLocString:

	*Index into the tlk files, this is 0xFFFFFFFF it unused
	int StringRef

	*The amount of strings this CExoLocString contains
	*Largly irrelevant as its recalculated when the gff is saved
	int StringCount

	*Total size in bytes (minus this field) that the CExoLocString contains
	*Largly irrelevant as its recalculated when the gff is saved
	int TotalSize

	*An array that contains the CExoLocSubstrings
	*this will be empty rather then nil if there are none
	array Strings

CExoLocStringSubString:

	*This is equal to LanguageID * 2 + gender (0 for masculine 1 for feminine)
	int StringID

	*Length of the string
	*Largly irrelevant as its recalculated when the gff is saved
	int StringLength

	*The string this exolocsubstring contains
	string String

xp_lua.dll ONLY (Starts with NWN.):

	-returns address of creature or nil of none exists
	string GetCreature(objid)

	-returns address of any object or nil of none exists
	string GetObject(objid)

	-retrives all variables in an array
	-Variable table: Name (Name of the var), Type (string, location, object, int, float), Data depends on the type
	-Location table: Position vector, Facing vector, Area objid
	table GetLocalVariables(objid)

	-Copies all effect ids to effectints index to
	-This can then be retrived using the nwscript function GetEffectInteger(eEffect, 10)
	bool CopyEffectIdsToEffectInts(objid)

	-Retrives information about an effect where effectid is retrivable using CopyEffectIdsToEffectInts
	-if effectid is not provided all effects will be provided in an array
	-table keys: 
	-ID: effect id
	-Creator: object id of the creator
	-Duration: float of the duration
	-ExpireDay: int some sort of internal timekeeping of the current day
	-ExpireTime: int some sort of interal timekeeping of the time in the ExpireDay to expire the effect
	-Exposed: bool if the effect is exposed to nwscripts GetFirst/NextEffect
	-ShowIcon: bool if the icon is shown
	-SpellID: int the spell id
	-CasterLevel: int casterlevel (might not be working)
	-LinkID: int Effects that share the same link share this id
	-Type: int the *internal* type of the effect
	-SubType: int *internal* subtype
	-EffectStrings array containing strings stored on the effect
	-EffectObjects array containing objectid's stored on the effect
	-EffectInts array of effect ints stored on the effect
	table GetEffectData(objid, effectid)

	-Sets the effect string on target index of the effect to newstring
	-idx must be between 0 and 5
	-Returns true/false
	bool SetEffectString(objid, effectid, idx, newstring)

	-Sets if the effect is to be considered exposed
	-an effect that is *not* exposed will not be returned by nwn2's GetFirst/NextEffect
	void EffectSetExposed(objid, effectid, bool)

	-Sets the effect int on target index of the effect to newint
	-idx must be between 0 and 9
	-Returns true/false
	bool EffectSetEffectInt(objid, effectid, idx, newint);

	-Sets the effect object on target index of the effect to object
	-idx must be between 0 and 3
	-Returns true/false
	bool SetEffectObject(objid, effectid, idx, newobjid);

	-Retrive a single variable from an object by name
	-if type is not given (or -1) it'll use the first variable by name
	-if a type is given it need to match too
	-types:
	-1: int
	-2: float
	-3: string
	-4: object
	-5: location
	value GetLocalVariable(objid, name, opt type)

	-Get or Set a creature script
	-If newscript is nil then no new script is set
	-returns the old script
	-Max index >= 25
	string SetGetCreatureScript(objid, index, opt newscript)

	-retrive the temp hp of a creature
	int GetTempHP(objid)

	-Set the temp hp of a creature
	void GetTempHP(objid, newhp)